# blog-service
Go 语言编程之旅第二章，博客程序

## 开启博客之旅
1. gin.Default 包含 Logger 和 Recovery 中间件
2. Logger 输出请求日志并标准化日志格式
3. Recovery 异常捕获，针对每个请求做 recovery 处理，防止出现 panic
4. gin 的路由也可以编辑测试代码
5. 注册路由时，会携带 Engine 的中间件
6. Engine 实现的 ServeHTTP 李永乐线程池的概念， 防止反复生成上下文对象

## 项目设计
1. 目录结构设计
   - configs: 配置文件
   - docs: 文档集合
   - global: 全局变量
   - internal: 内部模块
     - dao: 数据访问层， 所有数据库有关操作在此执行
     - middleware: HTTP 中间件
     - model: 模型层， 用于存放对象
     - routers: 路由相关逻辑处理
     - service: 项目核心业务逻辑
   - pkg: 项目相关模块包
   - storage: 项目生成的临时文件
   - scripts: 各类构建， 安装， 分析等操作的脚本
   - third_party: 第三方资源工具
2. 数据库的表设计， 先设计 SQL 语句， SQL 语句可以通过在线工具转换为 golang 结构体
3. 所有相关结构体封装到 model 包中
4. 从上到下， 先设定接口功能
5. 定制处理接口，先空置，处与 router 目录下
6. 测试路由是否能正常调用

## 编写公共组件
1. 五个模块
   - 错误码标准化
   - 配置管理
   - 数据库连接
   - 日志写入
   - 响应处理
2. 错误码标准化
   - 内部建立一套错误码
   - 通过单独的函数将错误码映射到对应的 HTTP 状态码
3. 配置管理
   - 启动时： 做一些初始化操作
   - 运行时： 监听文件的变更来实现在线更新配置
   - 写在单独的 yaml 文件中, 通过第三方库 viper 读取配置文件
   - 封装配置文件的读取
4. 数据库连接 注意可拓展性和编码规范
5. 日志写入
   - 第三方开源库 lumberjack 核心功能是将日志写入滚动文件
   - 日志所需的文件信息如文件名、行数需要从 runtime 获取
   - 其他主要还是在规范与封装上
6. 响应处理
   - 与错误码标准化相对应
7. **早期做标准化，后期省心省力**

## 生成接口文档
1. Swagger 扫描注解生成 OpenAPI 规范化文档
2. OpenAPI 规范
   - 有关 API 的描述
   - API 可用路径
   - 每个路径上的可用操作
   - 每个操作的输入输出格式
3. Swagger 需要的注解
   - @Summary 摘要
   - @Produce 响应类型
   - @Param 参数格式 从左到右参数为参数名，入参类型，数据类型，是否必填，注释
   - @Success 响应成功 从左到右参数为状态码，入参类型，数据类型，注释
   - @Failure 响应失败 从左到右参数为状态码，入参类型，数据类型，注释
   - @Router 路由 从左到右为路由地址 HTTP 方法
4. 主目录下执行 swag init
5. 路由
   - 在路由中注册 `r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))`
   - 同时要 `import` 对应的 `docs` 目录， 通过 `_` 引入不调用即可
   - 访问 `ip:port/swagger/index.html` 即可看到对应的OpenAPI接口文档
6. 隐藏字段不易于展示， 建议新建一个针对 `Swagger` 的对象

## 为接口做参数校验
1. 通过开源项目 go-playground/validator 做入参检测
2. 在结构体的 binding 中增加对应标签
3. 主要是利用外部包做开发，了解入参出参，信息的规范化

## 模块开发：标签管理
1. 学会使用 ORM 框架
   - Model: 指定实例模型，默认解析结构体名为表名，格式为大写驼峰转小写下划线驼峰。 也可以通过 TableName 方法返回表名
   - Offset: 偏移量，指定开始返回记录之前要跳过的记录数
   - Limit: 限制检索的记录数
2. 自定义回调机制
   - 有需要的话，学会使用 gorm.Scope，通过获取字段判断当前行为
   - 在连接引擎时，注册回调函数
3. 处理函数调用链 router -> service -> dao -> model
   - MVC 模型 <-- 视图 <-- 控制器
   - 模型： 负责数据和业务逻辑，通常包含数据存储、检索和业务规则
   - 视图： 负责显示数据，不包含业务逻辑
   - 控制器： 接收用户的输入，调用模型和视图去完成用户请求
   - 优点是 关注点分离， 易于维护， 可拓展性
   - 缺点是 增加复杂性，以及性能问题
4. GORM 中 Update 不会对结构体字段为零的值进行变更，因此在更新操作中可能出现漏洞。可以通过 Updates 传入 map 来解决该问题

## 图片上传和文件服务
1. 将文件格式、路径等加入配置文件中
2. 校验文件各项参数
3. 上传与保存服务
4. 静态文件服务 StaticFS

## 对接口进行访问控制
1. JWT 与 OAuth2.0 两种 API 访问控制方案
2. JWT (Json Web 令牌) 定义了紧凑且自包含的方式，用于在各方之间作为 JSON 对象安全地传输信息
   - 用三个 `.` 划分头部、有效载荷、签名
   - 首部： 签名算法与令牌类型。 JSON 序列化后用 base64UrlEncode 转换为 `JWT` 的第一部分
   - 有效载荷：JWT 中实际传输的数据。 JSON 序列化后用 base64UrlEncode 转换为 `JWT` 的第二部分
   - 签名： 前面两个部分的组合，用于校验信息在传输过程中是否有被篡改
   - base64UrlEncode 苏娜发中会将个别有特殊意义的字符进行替换，以保证 JWT 令牌在URL 中的可靠性和准确性
   - 场景为在内部约定好 JWT 交流方式，服务端提供一个获取 JWT 令牌的接口方法客户端请求其余接口时都要携带签发的 JWT 令牌鉴权
3. 使用流程(有点复杂)
   1. 添加 JWT 初始化配置， 比如说密钥、签发者、过期时间等
   2. 处理 JWT 令牌， 自定义一个对象，继承(就是包含) jwt.StandardClaims 对象
   3. 生成 Token 的函数
      - 有两个生成 token 用的封装函数
   4. 解析 Token 的函数
      - 同样有解析 token 用的对象，还有一个验证过期的字段
4. 获取 Token
   1. 入参检验
   2. 在数据库中校验 账号密码 
   3. 生成 token 字符串并返回
5. 检测 Token
   1. 通过中间件的方式检验 Token 是否正确
   2. 获取 Token
   3. 判断 Token 是否能够解析
   4. 判断 Token 是否过期

## 应用中间件
1. 记录访问日志，以探查问题出现的原因
   - 通过加入中间件，保存访问前与访问后的信息
2. 异常捕获处理
   - 添加 recover 中间件避免服务直接崩溃
   - 发生 panic 时通过邮件通知负责人处理导致 panic 的业务
     - 配置邮件服务
     - 添加邮件配置文件
     - 读取配置文件(这里可能存在安全问题，暂时不考虑实际发送邮件了)
3. 统一增加一些服务端信息
   - 通过中间件，在业务被真正访问前在 context 中增加一些元数据
4. 限流
   - 大概是新建了限流的接口，可实现多种限流模式
   - 但这里主要通过引用的包实现的，没有很搞懂
5. 统一超时控制
   - 在业务访问前，将 context 替换为携带超时的 context